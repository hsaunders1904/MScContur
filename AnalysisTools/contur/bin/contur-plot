#! /usr/bin/env python

from optparse import OptionParser
import os, sys
import contur.Utils as util
import contur as ct
from contur.Plotting import *
import pickle
import os, sys
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as sp
from os.path import join
import errno
from matplotlib.ticker import *
from collections import defaultdict

parser = OptionParser(usage=__doc__)
parser.add_option("-o", "--outputdir", dest="OUTPUTDIR",
                  default="plots", help="Specify output directory for output plots.")
parser.add_option("-v", "--version",
                  action="store_true", dest="printVersion",
                  default=False, help="print version number and exit.")
parser.add_option("-s", "--scan", dest="SCAN",
                  default="DMHF", help="Specify what model/parameters these maps refer to: DMLF, DMHF, MH2SA, ZPGP")
parser.add_option("-l", "--limit", dest="CLIMIT",
                  default="0.95", help="Conf limit of the contur")

opts, mapfiles = parser.parse_args()

if opts.printVersion:
    util.writeBanner()
    sys.exit(0)

if not mapfiles:
    sys.stderr.write("Error: You need to specify some contur.map files to be analysed!\n")
    sys.exit(1)


# function to decode the physical X value from the x axis grid variable
def xlab(x,dummy=0):
    if opts.SCAN == "ZPGP":
        return np.power(10,x/10.0)
    else:
        return x

# function to decode the physical Y value from the y axis variable
def ylab(y,dummy=0):
    if opts.SCAN == "MH2SA":
        y = np.sin(y*np.pi/40.0)
        return float('%3.1f' % y )
    elif opts.SCAN == "ZPGP":
        lab = 1.0*np.power(10,-y/4.0)
        return lab
    else:
        return y


# -------------------------- MAIN -----------------------
if __name__ == "__main__":
    util.mkoutdir(opts.OUTPUTDIR)

    contourXaxis=[]
    contourYaxis=[]

    climit = float(opts.CLIMIT)

# Axis labels (should get these from the conturDepot eventually?)
    if opts.SCAN == "MH2SA":
        xAxisLabel = r"$M_{H2}$ [GeV]"
        yAxisLabel = r"$\sin \alpha$"
    elif opts.SCAN == "ZPGP":
        xAxisLabel = r"$M_{Z'}$ [GeV]"
        yAxisLabel = r"$g'$"
    else:
        xAxisLabel = r"$M_{Z'}$ [GeV]"
        yAxisLabel = r"$M_{\textsc{dm}}$ [GeV]"

    # Build a dictionary to store the CL values for individual pools
    depots = {}

    # Build a dictionary to store the CL values for individual pools
    confLims  = defaultdict(list)
 
    for m in mapfiles:
        with open(m, 'r+b') as f:
            x = pickle.load(f)

        n_pools = len(x[0].sortedPoints)
        print "Loaded file", m, " which has ", n_pools, " pools"

        # array to store the total CL values this is maximum possible size (ie too big!)
        confLim = np.zeros((len(x),len(x)))

        # Sort them so the parameter values are in order.
        x.sort(key=lambda i: (float(i.ModelParam1), float(i.ModelParam2)))

        for ctp in x[0].sortedPoints:
            pool = ctp.pools
            confLims[pool] = np.zeros((len(x),len(x)))

        # TODO: this isn't going to work if there's more than one file containing the
        # same parameters points.
        for cDepot in x:
              #print "New conturDepot  ----"
              #print cDepot.ModelParam1, cDepot.ModelParam2
            if not cDepot.ModelParam1 in contourXaxis:
                contourXaxis.append(cDepot.ModelParam1)
            if not cDepot.ModelParam2 in contourYaxis:
                contourYaxis.append(cDepot.ModelParam2)
            
            ctp = cDepot.conturPoint
            key = cDepot.ModelParam1+cDepot.ModelParam2
            if not key in depots:
                depots[key] = cDepot
            else:
                depots[key].addPoint(ctp)
                depots[key].sortPoints()
              #print "adding", ctp.CLs
            
            ctp = depots[key].conturPoint
            confLim[contourXaxis.index(cDepot.ModelParam1)][contourYaxis.index(cDepot.ModelParam2)]=ctp.CLs

            for ctp in cDepot.sortedPoints:
                 #print ctp.tags
                 #print ctp.pools
                 #print ctp.CLs
                confLims[ctp.pools][contourXaxis.index(cDepot.ModelParam1)][contourYaxis.index(cDepot.ModelParam2)]  = ctp.CLs
                 #bestPlots[ctp.pools][contourXaxis.index(cDepot.ModelParam1)][contourYaxis.index(cDepot.ModelParam2)] = ctp.tags

# ended loop over points -------------------------------


# ended loop over files -------------------------------

            
# set up for the plots here.
    print "Setting up plots"

    Xaxis = np.array(map(float, contourXaxis))
    Yaxis = np.array(map(float, contourYaxis))

    # find the grid spacings:

    dx= ( min(filter(lambda x: x> min(Xaxis), (Xaxis))) - min(Xaxis))/2.0
    dy= ( min(filter(lambda x: x> min(Yaxis), (Yaxis))) - min(Yaxis))/2.0
    #print dx, dy

    yy,xx = np.mgrid[min(Yaxis)-dy:max(Yaxis)+2*dy:2*dy,min(Xaxis)-dx:max(Xaxis)+2*dx:2*dx]

    cl_values = confLim[:len(contourXaxis), :len(contourYaxis)]

    # translate from the parameters of the  to something more readable
    fmt = plt.FuncFormatter(xlab)
    fmt2 = plt.FuncFormatter(ylab)


# make an html index file for browsing them

    index = open("./plots/index.html", "w")

    index.write('<html>\n<head>\n<title>Heatmaps and contours</title>\n</head>\n<body>')

# make the overall heatmap
    print "Overall heatmap"

    fig=plt.figure(figsize=fig_dims)


    ax = fig.add_subplot(1,1,1)
    ax.xaxis.set_major_formatter(fmt)
    ax.yaxis.set_major_formatter(fmt2)

    if (opts.SCAN == "ZPGP"):
        my_locator_x = MaxNLocator((int(max(Xaxis)) / 10) + 1)
        my_locator_y = MaxNLocator((int(max(Yaxis)) / 4) + 1)
        ax.yaxis.set_major_locator(my_locator_y)
        ax.xaxis.set_major_locator(my_locator_x)

    plt.pcolormesh(xx,yy,cl_values.T,cmap=plt.cm.magma, vmin=0, vmax=1)

    # axis labels
    plt.xlabel(xAxisLabel)
    plt.ylabel(yAxisLabel)

    x_grid_min = min(Xaxis)
    if opts.SCAN == "DMLF":
        # plot the pert unitarity bound
        xub=np.array(Xaxis)
        xub[0]=xub[0]-dx
        yub=util.pertUnit(xub)
        plt.ylim(min(Yaxis)-dy,max(Yaxis)+dy)
        plt.plot(xub,yub,color='navy')
        ax.fill_between(xub,yub,max(Yaxis)+dy,facecolor='navy',alpha=0.4)
    elif opts.SCAN == "ZPGP":
        plt.ylim(min(Yaxis)-dy,max(Yaxis)+dy)
        plt.xlim(min(Xaxis)-dx,max(Xaxis)+dx)
        # plot the LEP bound
        y=np.array(Yaxis)
        x=util.LEPLimit(ylab(y))
        plt.plot(x,y,color='navy')
        ax.fill_between(x,y,x_grid_min,facecolor='navy',alpha=0.3)        
        # plot the ATLAS bound
        y=np.array([0.,1.,2.,3.,4.,5.,6.,7.,8.,9.1,9.2,9.3,9.4,9.5,9.6,9.7,9.8,9.9,10])
        x=util.ATLASLimit(ylab(y))
        plt.plot(x,y,color='navy')
        ax.fill_between(x,y,x_grid_min,facecolor='navy',alpha=0.2)        
        # plot the Borexino bound
        y=np.array(Yaxis)
        y[0]=y[0]-dy
        x=util.BorexinoLimit(ylab(y))
        plt.plot(x,y,color='navy')
        ax.fill_between(x,y,x_grid_min,facecolor='navy',alpha=0.3)
        # make g' go the right way.
        plt.gca().invert_yaxis()


    # save the fig and pad it for better layout
    fig.tight_layout(pad=0.1)
    pngfile = "./plots/combinedCL.png"
    contourpng = "./plots/contur.png"
    pdffile = "./plots/combinedCL.pdf"
    plt.savefig(pdffile)
    plt.savefig(pngfile)

    index.write('<h3>Combined Heatmap and contour</h3>')
    index.write('<img src="%s">\n' % os.path.basename(pngfile))
    index.write('<img src="%s">\n' % os.path.basename(contourpng))

    # now the heatmaps for the different analysis pools
    print "Subpool heatmaps"
    for pool in confLims:

        cl_values_pool = confLims[pool][:len(contourXaxis), :len(contourYaxis)]

        fig=plt.figure(figsize=fig_dims)
        ax = fig.add_subplot(1,1,1)
        ax.xaxis.set_major_formatter(fmt)
        ax.yaxis.set_major_formatter(fmt2)
        if opts.SCAN == "ZPGP":
            ax.yaxis.set_major_locator(my_locator_y)
            ax.xaxis.set_major_locator(my_locator_x)

        plt.pcolormesh(xx,yy,cl_values_pool.T,cmap=plt.cm.magma, vmin=0, vmax=1)

        # axis labels
        plt.xlabel(xAxisLabel)
        plt.ylabel(yAxisLabel)

        # save the fig and pad it for better layout
        if opts.SCAN == "ZPGP":
            plt.gca().invert_yaxis()
        fig.tight_layout(pad=0.1)
        pngfile = "./plots/combinedCL_"+pool+".png"
        plt.savefig(pngfile)
        index.write('<h4>%s</h4>' % pool)
        index.write('<img src="%s">\n' % os.path.basename(pngfile))
        plt.close(fig)

        

# Now the overall contour plot -------------------------------------------------------------------------------
    print "Overall contour plot"
    fig=plt.figure(figsize=fig_dims)

    ax = fig.add_subplot(1,1,1)
    ax.xaxis.set_major_formatter(fmt)
    ax.yaxis.set_major_formatter(fmt2)
    if (opts.SCAN == "ZPGP"):
        ax.yaxis.set_major_locator(my_locator_y)
        ax.xaxis.set_major_locator(my_locator_x)

    # draw a filled contour region for the CL excl
    CS=plt.contourf(Xaxis,Yaxis,cl_values.T,levels=[climit,1.0],label="CL",cmap=plt.cm.magma, alpha =0.8)
    # and a black outline
    CS2=plt.contour(CS, colors = 'black')


    # axis labels
    plt.xlabel(xAxisLabel)
    plt.ylabel(yAxisLabel)

    if opts.SCAN == "DMLF":
        # plot the pert unitarity bound
        xub=np.array(Xaxis)
        yub=util.pertUnit(xub)
        plt.ylim(min(Yaxis),max(Yaxis))
        plt.plot(xub,yub,color='navy')
        ax.fill_between(xub,yub,max(Yaxis),facecolor='navy',alpha=0.4)

    elif opts.SCAN == "ZPGP":
        # the theory constraints
        for i, x in enumerate(Xaxis):
            for j, y in enumerate(Yaxis):
                mzp = xlab(x).item()
                g1p = ylab(y).item()
                mh2 = mzp/(2.0*g1p)
                sina = 0.4
                  # sina = 4.0*1.772*g1p*246.0/mzp 
                  # if sina > 0.5:
                      # sina = 0.5
                vacon, percon, vapercon = util.bl3theory(mzp,g1p,mh2,sina)
                cl_values[i][j] = vapercon
        #plt.contour(xx,yy,cl_values)
        # draw a filled contour region for the CL excl
        CS=plt.contourf(Xaxis,Yaxis,cl_values.T,levels=[climit,1.0],label="CL",cmap=plt.cm.Greens, alpha =0.5)
        # and a black outline
        CS2=plt.contour(CS, colors = 'red')

        plt.gca().invert_yaxis()

    elif opts.SCAN == "MH2SA":
        # the theory constraints
        for i, x in enumerate(Xaxis):
            for j, y in enumerate(Yaxis):
                mh2 = xlab(x).item()
                sina = ylab(y)
                mzp = 7000.
                g1p = 1.0
                vacon, percon, vapercon = util.bl3theory(mzp,g1p,mh2,sina)
                cl_values[i][j] = vapercon
        #plt.contour(xx,yy,cl_values)
        # draw a filled contour region for the CL excl
        CS=plt.contourf(Xaxis,Yaxis,cl_values.T,levels=[climit,1.0],label="CL",cmap=plt.cm.Greens, alpha =0.5)
        # and a black outline
        CS2=plt.contour(CS, colors = 'red')

    fig.tight_layout(pad=0.1)
    plt.savefig("./plots/contur.pdf")
    plt.savefig("./plots/contur.png")


# Now the colour bar key --------------------------------------------------------------------------
    fig=plt.figure(figsize=[fig_dims[0]*2,0.5])
    ax = fig.add_subplot(1,1,1)
    import matplotlib as mpl
    norm = mpl.colors.Normalize(vmin=0, vmax=1)
    cb = mpl.colorbar.ColorbarBase(ax, cmap=plt.cm.magma, orientation='horizontal', norm=norm)
    cb.set_label("CL of exclusion")
    fig.tight_layout(pad=0.1)
    plt.savefig('./plots/colorbarkey.pdf')
    plt.savefig('./plots/colorbarkey.png')


# close the html file
    index.write("\n </body> \n")
    index.close()

    print "done"

