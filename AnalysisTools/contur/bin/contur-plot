#! /usr/bin/env python

from optparse import OptionParser
import os, sys
import contur.Utils as util
import contur as ct
from contur.Plotting import *
import pickle
import os, sys
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as sp
from os.path import join
import errno
from matplotlib.ticker import *
from collections import defaultdict

parser = OptionParser(usage=__doc__)
parser.add_option("-o", "--outputdir", dest="OUTPUTDIR",
                  default="plots", help="Specify output directory for output plots.")
parser.add_option("-v", "--version",
                  action="store_true", dest="printVersion",
                  default=False, help="print version number and exit.")
parser.add_option("-s", "--scan", dest="SCAN",
                  default="DMHF", help="Specify what model/parameters these maps refer to: DMLF, DMHF, MH2-SA")
parser.add_option("-l", "--limit", dest="CLIMIT",
                  default="0.95", help="Conf limit of the contur")

opts, mapfiles = parser.parse_args()

if opts.printVersion:
    util.writeBanner()
    sys.exit(0)

if not mapfiles:
    sys.stderr.write("Error: You need to specify some contur.map files to be analysed!\n")
    sys.exit(1)

##quick function to return the pertubative unitarity bound
#the 1.0 is gdm, currently hardcoded, grab from model file/ directory info eventually
def pertUnit(mz):
    gdm=0.25
    return np.sqrt(np.pi/2) * (mz/gdm)
    #return gdm * mdm / np.sqrt(np.pi/2)

# function to decode MH from the x axis variable
def xlab(x,dummy=0):
    if opts.SCAN == "Zg":
        return np.power(10,x/10.0)
    else:
        return int(x)

# function to decode sin(alpha) from the y axis variable
def ylab(y,dummy=0):
    if opts.SCAN == "MH2-SA":
        y = np.sin(y*np.pi/40.0)
        return float('%3.1f' % y )
    elif opts.SCAN == "Zg":
        lab = 1.0*np.power(10,-y/4.0)
        return lab
    else:
        return int(y)

# Various special functions for existing limits on different scans below.
# -----------------------------------------------------------------------------------------

# inverse of mzprime
def xfromMzp(mzp):
    return 10.0*np.log10(mzp)

# quick function to return the bound from LEP
# 
def LEPLimit(y):  
#  MZ'/g' > 6.9  so MZ' = g' * 6.9 TeV
    ret = []
    for val in y:
        mzp = ylab(val)*6900
        if mzp > 200.:
            ret.append(xfromMzp(mzp))
        else:
            ret.append(np.nan)
    return ret

# quick function to return the bound from ATLAS
# 
def ATLASLimit(y):    

#log10 g'/g = k M + c;  M = (log10(g'/g)-c)/k 
#0.1 = 2900 = -1
#1.0 = 5000 =  0
# so 5000k = -c,    -1 = 2900k + c = -2100k;    k = 1/2100, c = -5000/2100
#    sqrt(g'^2 + g^2) (SM) = 0.74
    k = 1.0/2100
    c = -50.0/21.0
    ret = []
    for val in y:
        mzp = (np.log10(ylab(val)/.74)-c)/k
        if mzp > 150.:
            ret.append(xfromMzp(mzp))
        else:
            ret.append(np.nan)
    return ret
           
def BorexinoLimit(y):  
#  MZ'/g' > 250  so MZ' = g' * 250 GeV
    return xfromMzp(ylab(y)*250)



if __name__ == "__main__":
    util.mkoutdir(opts.OUTPUTDIR)

    contourXaxis=[]
    contourYaxis=[]

    climit = float(opts.CLIMIT)

# Axis labels (should get these from the conturDepot eventually?)
    if opts.SCAN == "MH2-SA":
        xAxisLabel = r"$M_{H2}$ [GeV]"
        yAxisLabel = r"$\sin \alpha$"
    elif opts.SCAN == "Zg":
        xAxisLabel = r"$M_{Z'}$ [GeV]"
        yAxisLabel = r"$g'$"
    else:
        xAxisLabel = r"$M_{Z'}$ [GeV]"
        yAxisLabel = r"$M_{\textsc{dm}}$ [GeV]"

    # Build a dictionary to store the CL values for individual pools
    depots = {}

    # Build a dictionary to store the CL values for individual pools
    confLims  = defaultdict(list)
 
    for m in mapfiles:
        with open(m, 'r+b') as f:
            x = pickle.load(f)

        n_pools = len(x[0].sortedPoints)
        print "Loaded file", m, " which has ", n_pools, " pools"

        # array to store the total CL values this is maximum possible size (ie too big!)
        confLim = np.zeros((len(x),len(x)))

        # Sort them so the parameter values are in order.
        x.sort(key=lambda i: (float(i.ModelParam1), float(i.ModelParam2)))

        for ctp in x[0].sortedPoints:
            pool = ctp.pools
            confLims[pool] = np.zeros((len(x),len(x)))

        # TODO: this isn't going to work if there's more than one file containing the
        # same parameters points.
        for cDepot in x:
              #print "New conturDepot  ----"
              #print cDepot.ModelParam1, cDepot.ModelParam2
            if not cDepot.ModelParam1 in contourXaxis:
                contourXaxis.append(cDepot.ModelParam1)
            if not cDepot.ModelParam2 in contourYaxis:
                contourYaxis.append(cDepot.ModelParam2)
            
            ctp = cDepot.conturPoint
            key = cDepot.ModelParam1+cDepot.ModelParam2
            if not key in depots:
                depots[key] = cDepot
            else:
                depots[key].addPoint(ctp)
                depots[key].sortPoints()
              #print "adding", ctp.CLs
            
            ctp = depots[key].conturPoint
            confLim[contourXaxis.index(cDepot.ModelParam1)][contourYaxis.index(cDepot.ModelParam2)]=ctp.CLs

            for ctp in cDepot.sortedPoints:
                 #print ctp.tags
                 #print ctp.pools
                 #print ctp.CLs
                confLims[ctp.pools][contourXaxis.index(cDepot.ModelParam1)][contourYaxis.index(cDepot.ModelParam2)]  = ctp.CLs
                 #bestPlots[ctp.pools][contourXaxis.index(cDepot.ModelParam1)][contourYaxis.index(cDepot.ModelParam2)] = ctp.tags

# ended loop over points -------------------------------


# ended loop over files -------------------------------

            
# set up for the plots here.

    Xaxis = np.array(map(float, contourXaxis))
    Yaxis = np.array(map(float, contourYaxis))

    # find the grid spacings:

    dx= ( min(filter(lambda x: x> min(Xaxis), (Xaxis))) - min(Xaxis))/2.0
    dy= ( min(filter(lambda x: x> min(Yaxis), (Yaxis))) - min(Yaxis))/2.0
    #print dx, dy

    yy,xx = np.mgrid[min(Yaxis)-dy:max(Yaxis)+2*dy:2*dy,min(Xaxis)-dx:max(Xaxis)+2*dx:2*dx]

    cl_values = confLim[:len(contourXaxis), :len(contourYaxis)]

    # translate from the parameters of the  to something more readable
    fmt = plt.FuncFormatter(xlab)
    fmt2 = plt.FuncFormatter(ylab)


# make an html index file for browsing them

    index = open("./plots/index.html", "w")

    index.write('<html>\n<head>\n<title>Heatmaps and contours</title>\n</head>\n<body>')

# make the overall heatmap
    fig=plt.figure(figsize=fig_dims)


    ax = fig.add_subplot(1,1,1)
    ax.xaxis.set_major_formatter(fmt)
    ax.yaxis.set_major_formatter(fmt2)

    my_locator_x = MaxNLocator((int(max(Xaxis)) / 10) + 1)
    my_locator_y = MaxNLocator((int(max(Yaxis)) / 4) + 1)
    ax.yaxis.set_major_locator(my_locator_y)
    ax.xaxis.set_major_locator(my_locator_x)

    plt.pcolormesh(xx,yy,cl_values.T,cmap=plt.cm.magma, vmin=0, vmax=1)

    # axis labels
    plt.xlabel(xAxisLabel)
    plt.ylabel(yAxisLabel)

    x_grid_min = min(Xaxis)
    if opts.SCAN == "DMLF":
        # plot the pert unitarity bound
        xub=np.array(Xaxis)
        xub[0]=xub[0]-dx
        yub=pertUnit(xub)
        plt.ylim(min(Yaxis)-dy,max(Yaxis)+dy)
        plt.plot(xub,yub,color='navy')
        ax.fill_between(xub,yub,max(Yaxis)+dy,facecolor='navy',alpha=0.4)
    elif opts.SCAN == "Zg":
        plt.ylim(min(Yaxis)-dy,max(Yaxis)+dy)
        plt.xlim(min(Xaxis)-dx,max(Xaxis)+dx)
        # plot the LEP bound
        y=np.array(Yaxis)
        x=LEPLimit(y)
        plt.plot(x,y,color='navy')
        ax.fill_between(x,y,x_grid_min,facecolor='navy',alpha=0.3)        
        # plot the ATLAS bound
        y=[0.,1.,2.,3.,4.,5.,6.,7.,8.,9.1,9.2,9.3,9.4,9.5,9.6,9.7,9.8,9.9,10]
        x=ATLASLimit(y)
        plt.plot(x,y,color='navy')
        ax.fill_between(x,y,x_grid_min,facecolor='navy',alpha=0.2)        
        # plot the Borexino bound
        y=np.array(Yaxis)
        y[0]=y[0]-dy
        x=BorexinoLimit(y)
        plt.plot(x,y,color='navy')
        ax.fill_between(x,y,x_grid_min,facecolor='navy',alpha=0.3)
        # make g' go the right way.
        plt.gca().invert_yaxis()


    # save the fig and pad it for better layout
    fig.tight_layout(pad=0.1)
    pngfile = "./plots/combinedCL.png"
    contourpng = "./plots/contur.png"
    pdffile = "./plots/combinedCL.pdf"
    plt.savefig(pdffile)
    plt.savefig(pngfile)

    index.write('<h3>Combined Heatmap and contour</h3>')
    index.write('<img src="%s">\n' % os.path.basename(pngfile))
    index.write('<img src="%s">\n' % os.path.basename(contourpng))

    # now the heatmaps for the different analysis pools
    for pool in confLims:

        cl_values_pool = confLims[pool][:len(contourXaxis), :len(contourYaxis)]

        fig=plt.figure(figsize=fig_dims)
        ax = fig.add_subplot(1,1,1)
        ax.xaxis.set_major_formatter(fmt)
        ax.yaxis.set_major_formatter(fmt2)
        ax.yaxis.set_major_locator(my_locator_y)
        ax.xaxis.set_major_locator(my_locator_x)

        plt.pcolormesh(xx,yy,cl_values_pool.T,cmap=plt.cm.magma, vmin=0, vmax=1)

        # axis labels
        plt.xlabel(xAxisLabel)
        plt.ylabel(yAxisLabel)

        # save the fig and pad it for better layout
        if opts.SCAN == "Zg":
            plt.gca().invert_yaxis()
        fig.tight_layout(pad=0.1)
        pngfile = "./plots/combinedCL_"+pool+".png"
        plt.savefig(pngfile)
        index.write('<h4>%s</h4>' % pool)
        index.write('<img src="%s">\n' % os.path.basename(pngfile))
        plt.close(fig)

        

# Now the overall contour plot ---------------------------------
    fig=plt.figure(figsize=fig_dims)

    ax = fig.add_subplot(1,1,1)
    ax.xaxis.set_major_formatter(fmt)
    ax.yaxis.set_major_formatter(fmt2)
    ax.yaxis.set_major_locator(my_locator_y)
    ax.xaxis.set_major_locator(my_locator_x)

    # draw a filled contour region for the CL excl
    CS=plt.contourf(Xaxis,Yaxis,cl_values.T,levels=[climit,1.0],label="CL",cmap=plt.cm.magma, alpha =0.8)
    # and a black outline
    CS2=plt.contour(CS, colors = 'black')

    # axis labels
    plt.xlabel(xAxisLabel)
    plt.ylabel(yAxisLabel)

    if opts.SCAN == "DMLF":
        # plot the pert unitarity bound
        xub=np.array(Xaxis)
        yub=pertUnit(xub)
        plt.ylim(min(Yaxis),max(Yaxis))
        plt.plot(xub,yub,color='navy')
        ax.fill_between(xub,yub,max(Yaxis),facecolor='navy',alpha=0.4)

    if opts.SCAN == "Zg":
        plt.gca().invert_yaxis()

    fig.tight_layout(pad=0.1)
    plt.savefig("./plots/contur.pdf")
    plt.savefig("./plots/contur.png")


# Now the colour bar key ----------------------------------------
    fig=plt.figure(figsize=[fig_dims[0]*2,0.5])
    ax = fig.add_subplot(1,1,1)
    import matplotlib as mpl
    norm = mpl.colors.Normalize(vmin=0, vmax=1)
    cb = mpl.colorbar.ColorbarBase(ax, cmap=plt.cm.magma, orientation='horizontal', norm=norm)
    cb.set_label("CL of exclusion")
    fig.tight_layout(pad=0.1)
    plt.savefig('./plots/colorbarkey.pdf')
    plt.savefig('./plots/colorbarkey.png')


# close the html file
    index.write("\n </body> \n")
    index.close()

    print "done"

